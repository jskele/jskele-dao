package org.jskele.libs.dao.impl;

import app.data.*;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.DataRetrievalFailureException;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;

import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.concurrent.Executors.newFixedThreadPool;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.junit.Assert.fail;

@SpringBootTest
@RunWith(SpringRunner.class)
public class DaoInvocationHandlerTest {

    @Autowired
    private PlatformTransactionManager transactionManager;

    @Autowired
    private TestTableDao dao;

    @Autowired
    private TestTableWithUuidIdDao testTableWithUuidIdDao;

    @Autowired
    private NamedParameterJdbcTemplate jdbcTemplate;

    private Lock lock = new ReentrantLock();
    private ExecutorService executorService = newFixedThreadPool(2);

    @Test
    public void shouldInsertRowWithAutogeneratedId() {
        // Given
        TestTableRow row = TestTableRow.builder()
                .stringColumn("value")
                .numericColumn(99)
                .build();

        // When
        Long expectedGeneratedIdValue = 1 + getCurrentSeqValue();
        TestTableRowId insertedId = dao.insert(row);
        TestTableRow actual = dao.select(insertedId);

        // Then
        assertThat(insertedId.toValue(), equalTo(expectedGeneratedIdValue));

        assertThat(actual.getId().toValue(), equalTo(expectedGeneratedIdValue));
        assertThat(actual.getNumericColumn(), equalTo(99));
        assertThat(actual.getStringColumn(), equalTo("value"));
    }

    @Test
    public void shouldInsertRowWithExplicitId() {
        // Given
        TestTableRowId givenId = new TestTableRowId(55L);
        TestTableRow row = TestTableRow.builder()
                .id(givenId)
                .stringColumn("value")
                .numericColumn(99)
                .build();

        // When
        TestTableRowId returnedId = dao.insert(row);
        TestTableRow actual = dao.select(returnedId);

        // Then
        assertThat(returnedId, equalTo(givenId));

        assertThat(actual.getId(), equalTo(row.getId()));
        assertThat(actual.getNumericColumn(), equalTo(row.getNumericColumn()));
        assertThat(actual.getStringColumn(), equalTo(row.getStringColumn()));
    }

    @Test
    public void shouldInsertBatchRowsWithExplicitIds() {
        // Given
        TestTableRow row1 = createRow(101L, "batch1", 8);
        TestTableRow row2 = createRow(102L, "batch2", 9);

        // When
        dao.insertBatch(newArrayList(row1, row2));
        List<TestTableRow> actualRows = dao.findByNumericColumnIn("excludedValue", newArrayList(row1.getNumericColumn().longValue(), row2.getNumericColumn().longValue()));

        // Then
        assertThat(actualRows, hasSize(2));
    }

    @Test
    public void shouldInsertRowsWithAutogeneratedIds() {
        // Given
        TestTableRow row1 = createRow(null, "batch1AutogenId", 21);
        TestTableRow row2 = createRow(null, "batch2AutogenId", 22);

        // When
        dao.insertBatch(newArrayList(row1, row2));
        List<TestTableRow> actualRows = dao.findByNumericColumnIn("excludedValue", newArrayList(row1.getNumericColumn().longValue(), row2.getNumericColumn().longValue()));

        // Then
        assertThat(actualRows, hasSize(2));
    }

    @Test
    public void shouldBatchUpdate() {
        // Given
        TestTableRow row1 = createRow(1L, "row1", 11);
        TestTableRow row2 = createRow(3L, "batchUpdate3", 33);

        // When
        int[] updatedCounts = dao.updateBatch(newArrayList(row1, row2));
        List<TestTableRow> actualRows = dao.findByNumericColumnIn("excludedValue", newArrayList(11L, 33L));

        // Then
        assertThat(updatedCounts, equalTo(new int[]{1, 1}));
        assertThat(actualRows, hasSize(2));
    }

    @Test
    public void shouldUpdateRow() {
        // Given
        long idToBeUpdated = 1L;
        TestTableRow rowToBeUpdated = TestTableRow.builder()
                .id(new TestTableRowId(idToBeUpdated))
                .numericColumn(10)
                .build();
        TestTableRow expected = TestTableRow.builder()
                .id(new TestTableRowId(idToBeUpdated))
                .stringColumn("row1")
                .numericColumn(10)
                .build();

        // When
        int rowsUpdatedCount = dao.update(rowToBeUpdated);
        TestTableRow actual = dao.select(new TestTableRowId(idToBeUpdated));

        // Then
        assertThat(rowsUpdatedCount, equalTo(1));
        assertThat(actual, equalTo(expected));
    }

    @Test
    public void shouldDeleteRow() {
        // Given
        long id = 2L;

        // When
        int rowsAffected = dao.delete(new TestTableRowId(id));

        // Then
        assertThat(rowsAffected, equalTo(1));
    }

    @Test
    public void shouldQueryAllRows() {
        // When
        List<TestTableRow> result = dao.selectAll();

        // Then
        assertThat(result, hasSize(greaterThan(0)));
    }

    @Test
    public void shouldSelectForUpdate() {
        // Given
        ConcurrentLinkedQueue<Integer> executionOrder = new ConcurrentLinkedQueue<>();
        TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);

        TestTableRow row = TestTableRow.builder()
                .stringColumn("value")
                .numericColumn(99)
                .build();

        TestTableRowId insertedId = dao.insert(row);

        Callable<Void> firstUpdate = callable(1, insertedId, transactionTemplate, executionOrder);
        Callable<Void> secondUpdate = callable(2, insertedId, transactionTemplate, executionOrder);

        // When
        try {
            executorService.invokeAll(newArrayList(firstUpdate, secondUpdate));
        } catch (InterruptedException ignored) {
        }

        // Then
        TestTableRow actual = dao.select(insertedId);
        assertThat(actual.getNumericColumn(), not(equalTo(executionOrder.poll())));
        assertThat(actual.getNumericColumn(), equalTo(executionOrder.poll()));
    }

    @Test
    public void givenInsertMethodWithReturnTypeEqualToRowIdButNotAutogeneratedId_insertRowWithId_returnsId() {
        // Given
        TestTableWithUuidIdRowId givenId = new TestTableWithUuidIdRowId();
        TestTableWithUuidIdRow row = TestTableWithUuidIdRow.builder()
                .id(givenId)
                .stringColumn("whatEver")
                .numericColumn(42)
                .build();

        // When
        TestTableWithUuidIdRowId returnedId = testTableWithUuidIdDao.insert(row);
        TestTableWithUuidIdRow actual = testTableWithUuidIdDao.select(returnedId);

        // Then
        assertThat(returnedId, equalTo(givenId));

        assertThat(actual.getId(), equalTo(row.getId()));
        assertThat(actual.getNumericColumn(), equalTo(row.getNumericColumn()));
        assertThat(actual.getStringColumn(), equalTo(row.getStringColumn()));
    }

    @Test
    public void givenInsertMethodWithReturnTypeEqualToRowIdButNotAutogeneratedId_insertRowWithoutId_fails() {
        // Given
        TestTableWithUuidIdRowId givenId = null;
        TestTableWithUuidIdRow row = TestTableWithUuidIdRow.builder()
                .id(givenId)
                .stringColumn("whatEver")
                .numericColumn(42)
                .build();

        // When
        try {
            TestTableWithUuidIdRowId returnedId = testTableWithUuidIdDao.insert(row);
            fail("Expected exception when trying to insert row with id=null while id isn't autogenerated by DB, but got returnedId=" + returnedId);
        } catch (DataIntegrityViolationException e) {
            assertThat(e.getMessage(), containsString("null value in column \"id\" violates not-null constraint"));
        }
    }

    @Test
    public void givenExistingId_exists_returnsTrue() {
        // Given
        TestTableRowId id = new TestTableRowId(1L);
        // When
        boolean exists = dao.exists(id);
        // Then
        assertThat(exists, equalTo(true));
    }

    @Test
    public void givenNonExistingId_exists_returnsFalse() {
        // Given
        TestTableRowId id = new TestTableRowId(Long.MAX_VALUE);
        // When
        boolean exists = dao.exists(id);
        // Then
        assertThat(exists, equalTo(false));
    }

    @Test
    public void givenQueryForNoResults_find_returnsNull() {
        // Given
        String stringColumn = "notMatchingValue";
        // When
        TestTableRow result = dao.findByStringColumn(stringColumn);
        // Then
        assertThat(result, equalTo(null));
    }

    @Test
    public void givenQueryForOneResult_find_returnsRow() {
        // Given
        String stringColumn = "queryForOneResult-" + System.currentTimeMillis();
        TestTableRow row = TestTableRow.builder().stringColumn(stringColumn).build();
        TestTableRowId id = dao.insert(row);
        // When
        TestTableRow result = dao.findByStringColumn(stringColumn);
        // Then
        assertThat(result.getId(), equalTo(id));
        assertThat(result.getStringColumn(), equalTo(stringColumn));
    }

    @Test(expected = DataRetrievalFailureException.class)
    public void givenQueryForMultipleResult_find_throwsException() {
        // Given
        String stringColumn = "row1";
        dao.insert(TestTableRow.builder()
                .stringColumn(stringColumn)
                .build()
        );
        // When
        TestTableRow result = dao.findByStringColumn(stringColumn);
        // Then
        fail("Expected exception, got " + result);
    }

    private Callable<Void> callable(int id, TestTableRowId insertedId, TransactionTemplate transactionTemplate, ConcurrentLinkedQueue<Integer> queue) {
        return () -> transactionTemplate.execute(status -> {
            TestTableRow row;
            try {
                lock.lock();
                queue.add(id);
                row = dao.selectForUpdate(insertedId);
            } finally {
                lock.unlock();
            }

            try {
                // delay first thread update
                TimeUnit.MILLISECONDS.sleep(queue.peek() == id ? 100 : 0);
            } catch (InterruptedException ignored) {
            }

            TestTableRow updatedRow = TestTableRow.builder()
                    .id(row.getId())
                    .stringColumn(row.getStringColumn())
                    .numericColumn(id)
                    .build();

            dao.update(updatedRow);
            return null;
        });
    }

    private TestTableRow createRow(Long id, String value, int numeric) {
        return TestTableRow.builder()
                .id(id == null ? null : new TestTableRowId(id))
                .stringColumn(value)
                .numericColumn(numeric)
                .build();
    }

    private Long getCurrentSeqValue() {
        return jdbcTemplate.queryForObject("SELECT currval('test_table_id_seq'::regclass)", (Map<String, ?>) null, Long.class);
    }

}
