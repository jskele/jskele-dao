package org.jskele.dao.impl;

import app.data.*;
import app.data.TestTableRow.JsonColumn;
import org.hamcrest.MatcherAssert;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.DataRetrievalFailureException;
import org.springframework.jdbc.BadSqlGrammarException;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;

import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.concurrent.Executors.newFixedThreadPool;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.fail;

@SpringBootTest
@ExtendWith(SpringExtension.class)
public class DaoInvocationHandlerTest {

    @Autowired
    private PlatformTransactionManager transactionManager;

    @Autowired
    private TestTableDao dao;

    @Autowired
    private TestTableWithUuidIdDao testTableWithUuidIdDao;

    @Autowired
    private NamedParameterJdbcTemplate jdbcTemplate;

    private Lock lock = new ReentrantLock();
    private ExecutorService executorService = newFixedThreadPool(2);

    @Test
    public void shouldInsertRowWithAutogeneratedId() {
        // Given
        TestTableRow row = TestTableRow.builder()
                .stringColumn("value")
                .numericColumn(99)
                .jsonColumn(new JsonColumn("{}"))
                .build();

        // When
        Long expectedGeneratedIdValue = 1 + getCurrentSeqValue();
        TestTableRowId insertedId = dao.insert(row);
        TestTableRow actual = dao.select(insertedId);

        // Then
        assertThat(insertedId.toValue(), equalTo(expectedGeneratedIdValue));

        assertThat(actual.getId().toValue(), equalTo(expectedGeneratedIdValue));
        assertThat(actual.getNumericColumn(), equalTo(99));
        assertThat(actual.getStringColumn(), equalTo("value"));
        assertThat(actual.getJsonColumn(), equalTo(row.getJsonColumn()));
    }

    @Test
    public void shouldInsertRowWithExplicitId() {
        // Given
        TestTableRowId givenId = getUnusedTableRowId();

        TestTableRow row = TestTableRow.builder()
                .id(givenId)
                .stringColumn("value")
                .numericColumn(99)
                .build();

        // When
        TestTableRowId returnedId = dao.insert(row);
        TestTableRow actual = dao.select(returnedId);

        // Then
        assertThat(returnedId, equalTo(givenId));

        assertThat(actual.getId(), equalTo(row.getId()));
        assertThat(actual.getNumericColumn(), equalTo(row.getNumericColumn()));
        assertThat(actual.getStringColumn(), equalTo(row.getStringColumn()));
    }

    @Test
    public void shouldInsertBatchRowsWithExplicitIds() {
        // Given
        TestTableRow row1 = createRow(getUnusedTableRowId(), "batch1", 8);
        TestTableRow row2 = createRow(getUnusedTableRowId(), "batch2", 9);

        // When
        dao.insertBatch(newArrayList(row1, row2));

        // Then
        TestTableRow persistedRow1 = dao.select(row1.getId());
        assertThat(persistedRow1, equalTo(row1));
    }

    @Test
    public void shouldInsertRowsWithAutogeneratedIds() {
        // Given
        TestTableRow row1 = createRow(null, "batch1AutogenId", (int) System.currentTimeMillis());
        TestTableRow row2 = createRow(null, "batch2AutogenId", row1.getNumericColumn() + 1);

        // When
        dao.insertBatch(newArrayList(row1, row2));
        List<TestTableRow> actualRows = dao.findByNumericColumnIn("excludedValue", newArrayList(row1.getNumericColumn().longValue(), row2.getNumericColumn().longValue()));

        // Then
        assertThat(actualRows, hasSize(2));
    }

    @Test
    public void shouldBatchUpdate() {
        // Given
        TestTableRow row1 = createRow(new TestTableRowId(1L), "row1", 11);
        TestTableRow row2 = createRow(new TestTableRowId(3L), "batchUpdate3", 33);

        // When
        int[] updatedCounts = dao.updateBatch(newArrayList(row1, row2));
        List<TestTableRow> actualRows = dao.findByNumericColumnIn("excludedValue", newArrayList(11L, 33L));

        // Then
        assertThat(updatedCounts, equalTo(new int[]{1, 1}));
        assertThat(actualRows, hasSize(2));
        TestTableRow persistedRow1 = dao.select(row1.getId());
        assertThat(persistedRow1, equalTo(row1));
    }

    @Test
    public void shouldUpdateRow() {
        // Given
        long idToBeUpdated = 1L;
        TestTableRow rowToBeUpdated = TestTableRow.builder()
                .id(new TestTableRowId(idToBeUpdated))
                .numericColumn(10)
                .jsonColumn(new JsonColumn("{\"a\":\"b\"}"))
                .build();
        TestTableRow expected = TestTableRow.builder()
                .id(new TestTableRowId(idToBeUpdated))
                .stringColumn("row1")
                .numericColumn(10)
                .jsonColumn(rowToBeUpdated.getJsonColumn())
                .build();

        // When
        int rowsUpdatedCount = dao.update(rowToBeUpdated);
        TestTableRow actual = dao.select(new TestTableRowId(idToBeUpdated));

        // Then
        assertThat(rowsUpdatedCount, equalTo(1));
        assertThat(actual, equalTo(expected));
    }

    @Test
    public void shouldDeleteRow() {
        // Given
        TestTableRowId id = dao.insert(TestTableRow.builder().stringColumn("shouldDeleteRow-" + System.currentTimeMillis()).build());

        // When
        int rowsAffected = dao.delete(id);

        // Then
        assertThat(rowsAffected, equalTo(1));
    }

    @Test
    public void shouldQueryAllRows() {
        // When
        List<TestTableRow> result = dao.selectAll();

        // Then
        assertThat(result, hasSize(greaterThan(0)));
    }

    @Test
    public void shouldSelectForUpdate() {
        // Given
        ConcurrentLinkedQueue<Integer> executionOrder = new ConcurrentLinkedQueue<>();
        TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);

        TestTableRow row = TestTableRow.builder()
                .stringColumn("value")
                .numericColumn(99)
                .build();

        TestTableRowId insertedId = dao.insert(row);

        Callable<Void> firstUpdate = callable(1, insertedId, transactionTemplate, executionOrder);
        Callable<Void> secondUpdate = callable(2, insertedId, transactionTemplate, executionOrder);

        // When
        try {
            executorService.invokeAll(newArrayList(firstUpdate, secondUpdate));
        } catch (InterruptedException ignored) {
        }

        // Then
        TestTableRow actual = dao.select(insertedId);
        assertThat(actual.getNumericColumn(), not(equalTo(executionOrder.poll())));
        assertThat(actual.getNumericColumn(), equalTo(executionOrder.poll()));
    }

    @Test
    public void givenInsertMethodWithReturnTypeEqualToRowIdButNotAutogeneratedId_insertRowWithId_returnsId() {
        // Given
        TestTableWithUuidIdRowId givenId = new TestTableWithUuidIdRowId();
        TestTableWithUuidIdRow row = TestTableWithUuidIdRow.builder()
                .id(givenId)
                .stringColumn("whatEver")
                .numericColumn(42)
                .build();

        // When
        TestTableWithUuidIdRowId returnedId = testTableWithUuidIdDao.insert(row);
        TestTableWithUuidIdRow actual = testTableWithUuidIdDao.select(returnedId);

        // Then
        assertThat(returnedId, equalTo(givenId));

        assertThat(actual.getId(), equalTo(row.getId()));
        assertThat(actual.getNumericColumn(), equalTo(row.getNumericColumn()));
        assertThat(actual.getStringColumn(), equalTo(row.getStringColumn()));
    }

    @Test
    public void givenInsertMethodWithReturnTypeEqualToRowIdButNotAutogeneratedId_insertRowWithoutId_fails() {
        // Given
        TestTableWithUuidIdRowId givenId = null;
        TestTableWithUuidIdRow row = TestTableWithUuidIdRow.builder()
                .id(givenId)
                .stringColumn("whatEver")
                .numericColumn(42)
                .build();

        // When
        try {
            TestTableWithUuidIdRowId returnedId = testTableWithUuidIdDao.insert(row);
            fail("Expected exception when trying to insert row with id=null while id isn't autogenerated by DB, but got returnedId=" + returnedId);
        } catch (DataIntegrityViolationException e) {
            assertThat(e.getMessage(), containsString("null value in column \"id\" violates not-null constraint"));
        }
    }

    @Test
    public void givenRowWithId_insertWithVoidReturnType_succeeds() {
        // Given
        TestTableWithUuidIdRow row = TestTableWithUuidIdRow.builder()
                .id(new TestTableWithUuidIdRowId())
                .stringColumn("whatEver inserted")
                .build();

        // When
        testTableWithUuidIdDao.insertWithVoidReturnType(row);

        // Then
        TestTableWithUuidIdRow persistedRow = testTableWithUuidIdDao.select(row.getId());
        assertThat(persistedRow, equalTo(row));
    }

    @Test
    public void givenModifiedRow_updateMethodWithVoidReturnType_updatesPersistedRow() {
        // Given
        TestTableWithUuidIdRow row = TestTableWithUuidIdRow.builder()
                .id(new TestTableWithUuidIdRowId())
                .stringColumn("whatEver to be updated")
                .build();
        testTableWithUuidIdDao.insert(row);

        // When
        row = row.withStringColumn("updated at " + System.currentTimeMillis());
        testTableWithUuidIdDao.updateMethodWithVoidReturnType(row);

        // Then
        TestTableWithUuidIdRow updatedRow = testTableWithUuidIdDao.select(row.getId());
        assertThat(updatedRow, equalTo(row));
    }

    @Test
    public void givenExistingRowId_deleteWithVoidReturnType_deletesRow() {
        // Given
        TestTableWithUuidIdRow row = TestTableWithUuidIdRow.builder()
                .id(new TestTableWithUuidIdRowId())
                .stringColumn("whatEver to be deleted")
                .build();
        testTableWithUuidIdDao.insertWithVoidReturnType(row);

        // When
        testTableWithUuidIdDao.deleteWithVoidReturnType(row.getId());

        // Then
        MatcherAssert.assertThat(testTableWithUuidIdDao.exists(row.getId()), equalTo(false));
    }

    @Test
    public void givenExistingId_exists_returnsTrue() {
        // Given
        TestTableRowId id = new TestTableRowId(1L);
        // When
        boolean exists = dao.exists(id);
        // Then
        assertThat(exists, equalTo(true));
    }

    @Test
    public void givenNonExistingId_exists_returnsFalse() {
        // Given
        TestTableRowId id = new TestTableRowId(Long.MAX_VALUE);
        // When
        boolean exists = dao.exists(id);
        // Then
        assertThat(exists, equalTo(false));
    }

    @Test
    public void givenQueryForNoResults_find_returnsNull() {
        // Given
        String stringColumn = "notMatchingValue";
        // When
        TestTableRow result = dao.findByStringColumn(stringColumn);
        // Then
        assertThat(result, equalTo(null));
    }

    @Test
    public void givenQueryForOneResult_find_returnsRow() {
        // Given
        String stringColumn = "queryForOneResult-" + System.currentTimeMillis();
        TestTableRow row = TestTableRow.builder().stringColumn(stringColumn).build();
        TestTableRowId id = dao.insert(row);
        // When
        TestTableRow result = dao.findByStringColumn(stringColumn);
        // Then
        assertThat(result.getId(), equalTo(id));
        assertThat(result.getStringColumn(), equalTo(stringColumn));
    }

    @Test
    public void givenQueryForMultipleResult_find_throwsException() {
        // Given
        String stringColumn = "row1";
        dao.insert(TestTableRow.builder()
                .stringColumn(stringColumn)
                .build()
        );
        // When
        assertThrows(DataRetrievalFailureException.class, () -> {
            TestTableRow result = dao.findByStringColumn(stringColumn);
            // Then
            fail("Expected exception, got " + result);
        });
    }

    @Test
    public void givenJsonValueInSearchConstraint_find_failsWithExceptionAsImplementationIsntEnabled() {
        // Given
        long timestamp = System.currentTimeMillis();
        TestTableRow row1 = TestTableRow.builder()
                .jsonColumn(new JsonColumn("{\"timestamp\":\"" + timestamp + "\"}"))
                .build();
        dao.insert(row1);
        TestTableRow row2 = row1.toBuilder()
                .jsonColumn(new JsonColumn("{\"timestamp\":\"" + timestamp + 1 + "\"}"))
                .build();
        dao.insert(row2);
        // When
        assertThrows(BadSqlGrammarException.class,
                () -> dao.findByJsonColumn(row2.getJsonColumn()),
                "Expected that usage of JsonValue in SQL WHERE clause isn't enabled (and throws exception) - not sure if it should be enabled or not"
        );
    }

    @Test
    public void givenSqlTemplateWithNullableParameterWithNullValue_find_returnsRow() {
        testSqlTemplateWithNullableParameter(null);
    }

    @Test
    public void givenSqlTemplateWithNullableParameterWithNotNullValue_find_returnsRow() {
        testSqlTemplateWithNullableParameter(1);
    }

    private void testSqlTemplateWithNullableParameter(Integer numericColumnValue) {
        String stringColumn = "numeric_column couldBeNULL";
        // When
        TestTableRow result = dao.findByStringColumnAndNullableNumericColumn(stringColumn, numericColumnValue);
        // Then
        assertThat(result, notNullValue());
        assertThat(result.getNumericColumn(), equalTo(numericColumnValue));
    }

    private Callable<Void> callable(int id, TestTableRowId insertedId, TransactionTemplate transactionTemplate, ConcurrentLinkedQueue<Integer> queue) {
        return () -> transactionTemplate.execute(status -> {
            TestTableRow row;
            try {
                lock.lock();
                queue.add(id);
                row = dao.selectForUpdate(insertedId);
            } finally {
                lock.unlock();
            }

            try {
                // delay first thread update
                TimeUnit.MILLISECONDS.sleep(queue.peek() == id ? 100 : 0);
            } catch (InterruptedException ignored) {
            }

            TestTableRow updatedRow = TestTableRow.builder()
                    .id(row.getId())
                    .stringColumn(row.getStringColumn())
                    .numericColumn(id)
                    .build();

            dao.update(updatedRow);
            return null;
        });
    }

    private TestTableRow createRow(TestTableRowId id, String value, int numeric) {
        return TestTableRow.builder()
                .id(id)
                .stringColumn(value)
                .numericColumn(numeric)
                .jsonColumn(new JsonColumn("{\"value\":\"" + value + "\"}"))
                .build();
    }

    private TestTableRowId getUnusedTableRowId() {
        TestTableRowId givenId = dao.insert(TestTableRow.builder().stringColumn("shouldDeleteRow-" + System.currentTimeMillis()).build());
        dao.delete(givenId);
        MatcherAssert.assertThat(dao.exists(givenId), equalTo(false));
        return givenId;
    }

    private Long getCurrentSeqValue() {
        return jdbcTemplate.queryForObject("SELECT currval('test_table_id_seq'::regclass)", (Map<String, ?>) null, Long.class);
    }

}
